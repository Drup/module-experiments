\documentclass[a4paper,11pt]{beamer}
\usepackage{minted}
\usepackage{alltt}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{xspace}
\usetheme{Boadilla}
\usepackage[scaled=0.8]{DejaVuSansMono} % A decent mono font
%\usepackage{enumitem}
%\setitemize{noitemsep,topsep=3pt,parsep=3pt,partopsep=3pt}
%\setenumerate{noitemsep,topsep=3pt,parsep=3pt,partopsep=3pt}


\newcommand{\error}[1]{\textcolor{red}{#1}}
\newcommand{\ok}[1]{\textcolor{OliveGreen}{#1}}

\title[Functor diffing]{High-level error messages for modules through diffing}
\author[Angeletti \& Radanne]{\texorpdfstring{
  \begin{columns}\column{0.5\linewidth}\centering%
  Florian \textsc{Angeletti}\\
  Inria\\
  \href{mailto:florian.angeletti@inria.fr}
  {\nolinkurl{florian.angeletti@inria.fr}}
  \column{0.5\linewidth}\centering%
  Gabriel \textsc{Radanne}\\
  Inria\\
  \href{mailto:gabriel.radanne@inria.fr}
  {\nolinkurl{gabriel.radanne@inria.fr}}
  \end{columns}
  }{F. Angeletti \& G. Radanne}}
\date{Thursday 27th August}
\begin{document}
\begin{frame}
\maketitle
\end{frame}

\section{Module errors}

\begin{frame}
  \structure{In ML languages, error messages for type error at the module level
    are notoriously hard to read}.
\end{frame}

\begin{frame}[fragile]\frametitle{}

\begin{minted}{ocaml}
module type f =
  functor
    (B:sig type x type y type u=x type v=y end)
    (Y:sig type yu = Y of B.u end)
    (Z:sig type zv = Z of B.v end)
   -> sig end
module F: f =
  functor
    (X:sig type x type y end)
    (Z:sig type zv = Z of X.y end)
   -> struct end
\end{minted}

\end{frame}

\begin{frame}[fragile]\frametitle{When errors grow}

\begin{alltt}\error{Error}: Signature mismatch:
       Modules do not match:
         functor (X : sig type x type y end) (Z : sig type zv = Z of X.y end)
           -> sig end
       is not included in
         f
       At position functor (X) -> <here>
       Modules do not match:
         functor (Z : sig type zv = Z of X.y end) -> sig end
       is not included in
         functor (Y : sig type yu = Y of X.x end)
           (Z : sig type zv = Z of X.y end) -> sig end
\end{alltt}

\end{frame}

\begin{frame}[fragile]\frametitle{When errors grow}

\begin{alltt}
       At position functor (X) -> functor (Z : <here>) -> ...
       The type `zv' is required but not provided
\end{alltt}

\end{frame}


\begin{frame}\frametitle{Modules: theory vs practice}
\begin{description}
\item[Theory:]{Most complex part of the language}
\item[Practice:]{Shallow hierarchy of submodules, a handful of functors with few arguments, few module types}
\end{description}

\end{frame}

\begin{frame}[fragile]\frametitle{A typical example}
A common example of functors
\begin{minted}{ocaml}
module type XT = sig type x end
module type YT = sig type y end
module type ZT = sig type z end
module F(X:XT)(Y:YT)(Z:ZT)
= struct ... end
module X = struct type x = A end
module Y = struct type y = B end
module Y' = struct type y' = B end
module Z = struct type z = C end
\end{minted}

\end{frame}

\begin{frame}[fragile]\frametitle{Common errors}

  \begin{itemize}
    \item{Unnecessary argument
\begin{minted}{ocaml}
module R = F(X)(X)(Y)(Z)
\end{minted}
      }
    \item{Forgotten argument:
\begin{minted}{ocaml}
module R = F(X)(Z)
\end{minted}
      }
    \item{Wrong argument:
\begin{minted}{ocaml}
module R = F(X)(Y')(Z)
\end{minted}
      }
\end{itemize}

All those errors are frequent during the refactoring.

\end{frame}

\begin{frame}[fragile]
Classical error messages consider only the last alternative:

\begin{minted}{ocaml}
module R = F(X)(X)(Y)(Z)
\end{minted}

\begin{alltt}
\error{Error}: Signature mismatch:
       Modules do not match:
         sig type x = X.x = A end
       is not included in
         sig type y = B end
       The type `y' is required but not provided
 \end{alltt}
\end{frame}


\section{Diffing higher level error}


\begin{frame}[fragile]\frametitle{Going higher}

  By typechecking argument by argument, we lose the multi-application
  context:
\begin{minted}{ocaml}
module R = F(X)(X)(Y)(Z)
\end{minted}

  \begin{itemize}
      \item For error message, we should look at the whole multi-application
\begin{minted}{ocaml}
module R = F(X)(X)(Y)(Z)
\end{minted}

  \end{itemize}
Try to match
\begin{minted}{ocaml}
 F(X)(X)(Y)(Z)
\end{minted}
with the list
\begin{minted}{ocaml}
 module F(X:XT)(Y:YT)(Z:ZT) = ...
\end{minted}

using the minimal number of addition, deletion, or modification on both side.

\end{frame}


\begin{frame}[fragile]\frametitle{Unnecessary argument}
\begin{minted}{ocaml}
module R=F(X)(X)(Y)(Z)
\end{minted}
\begin{alltt}
{\bfseries{}\color{red}{}Error}: The functor application is ill-typed.
       These arguments:
         {\color{green}{}X} {\color{red}{}\bfseries{}X} {\color{green}{}Y} {\color{green}{}Z}
       do not match these parameters:
         functor {\color{green}{}(X : XT)} {\color{red}{}\bfseries{}} {\color{green}{}(Y : YT)} {\color{green}{}(Z : ZT)} -> ...
  {\color{green}{}1.} Module X matches the expected module type XT
  {\color{red}{}\bfseries{}2.} The following extra argument is provided
     X : sig type x = X.x = A end
  {\color{green}{}3.} Module Y matches the expected module type YT
  {\color{green}{}4.} Module Z matches the expected module type ZT
\end{alltt}
\end{frame}

\begin{frame}[fragile]\frametitle{Missing argument}
\begin{minted}{ocaml}
module R=F(X)(Z)
\end{minted}
\begin{alltt}
{\bfseries{}\color{red}{}Error}: The functor application is ill-typed.
       These arguments:
         {\color{green}{}X} {\color{red}{}\bfseries{}} {\color{green}{}Z}
       do not match these parameters:
         functor {\color{green}{}(X : XT)} {\color{red}{}\bfseries{}(Y : YT)} {\color{green}{}(Z : ZT)} -> ...
  {\color{green}{}1.} Module X matches the expected module type XT
  {\color{red}{}\bfseries{}2.} An argument appears to be missing with module type YT
  {\color{green}{}3.} Module Z matches the expected module type ZT
\end{alltt}
\end{frame}

\begin{frame}[fragile]\frametitle{Wrong argument}
\begin{minted}{ocaml}
module R=F(X)(Y')(Z)
\end{minted}
\begin{alltt}
{\bfseries{}\color{red}{}Error}: The functor application is ill-typed.
       These arguments:
         {\color{green}{}X} {\color{magenta}{}\bfseries{}Y'} {\color{green}{}Z}
       do not match these parameters:
         functor {\color{green}{}(X : XT)} {\color{magenta}{}\bfseries{}(Y : YT)} {\color{green}{}(Z : ZT)} -> ...
  {\color{green}{}1.} Module X matches the expected module type XT
  {\color{magenta}{}\bfseries{}2.} Modules do not match:
       Y' : sig type y' = Y'.y' = B end
     is not included in
       YT
     The type `y' is required but not provided
  {\color{green}{}3.} Module Z matches the expected module type ZT
\end{alltt}
\end{frame}

\begin{frame}[fragile]\frametitle{Mixed errors}
\begin{minted}{ocaml}
module A = Seq module A' = Complex
module B = Option module B' = Bigarray
module C = Result module C' = Bool
module D = Char module D' = Uchar
module E = Sys module E' = List
module F = Bytes module F' = Map.Make
module G = String
\end{minted}
\end{frame}
\begin{frame}[fragile]\frametitle{Mixed errors}
\begin{minted}{ocaml}
module Little_functor =
    (A: module type of A) (B: module type of B)
    (C: module type of C) (D: module type of D)
    (E: module type of E) (F: module type of F)
    (G: module type of G) (H: module type of H)
    = struct end
\end{minted}
\end{frame}

\begin{frame}[fragile]\frametitle{Mixed errors}
\begin{minted}{ocaml}
module E = Little(A)(A)(B)(C')(E)(F')(G)(H)(H)
\end{minted}
\begin{alltt}
These arguments:
  {\color{green}{}A} {\color{red}{}\bfseries{}A} {\color{green}{}B} {\color{magenta}{}\bfseries{}C'} {\color{red}{}\bfseries{}} {\color{green}{}E} {\color{magenta}{}\bfseries{}F'} {\color{green}{}G} {\color{green}{}H} {\color{red}{}\bfseries{}H'}
do not match these parameters:
  functor {\color{green}{}(A : ...)} {\color{red}{}\bfseries{}} {\color{green}{}(B : ...)} {\color{magenta}{}\bfseries{}(C : ...(C))} {\color{red}{}\bfseries{}(D : ...(D))} {\color{green}{}(E : ...)}
  {\color{magenta}{}\bfseries{}(F : ...(F))} {\color{green}{}(G : ...)} {\color{green}{}(H : ...)} {\color{red}{}\bfseries{}} -> ...
{\color{green}{}1.} Module A matches the expected module type
{\color{red}{}\bfseries{}2.} The following extra argument is provided
  ...
\end{alltt}
\end{frame}


\begin{frame}\frametitle{Edit distance optimization}
  \structure{Dynamically-sized variant of the Wagner-Fischer algorithm for computing edit distance}
  \begin{itemize}
    \item{Argument comparison: OCaml typechecker comparison used as a black box}
    \item{Complexity: $O(\max(\mathrm{|arguments|,|parameters|})^2)$}
    \item{implemented as a patch on the OCaml compiler:
      https://github.com/ocaml/ocaml/pull/9331 }
  \end{itemize}
\end{frame}


\section{Complex examples}

\begin{frame}
  \structure{Does this scale?}
\end{frame}

\begin{frame}[fragile]\frametitle{Opening example}
\begin{minted}{ocaml}
module type f =
  functor
    (B:sig type x type y type u=x type v=y end)
    (Y:sig type yu = Y of B.u end)
    (Z:sig type zv = Z of B.v end)
   -> sig end
module F: f =
  functor
    (X:sig type x type y end)
    (Z:sig type zv = Z of X.y end)
   -> struct end
\end{minted}
\end{frame}

\begin{frame}[fragile]\frametitle{Opening example}
\begin{alltt}
{\bfseries{}\color{red}{}Error}: Signature mismatch:
       Modules do not match:
         functor {\color{green}{}(X : ...(X))} {\color{red}{}\bfseries{}} {\color{green}{}(Z : ...(Z))} -> ...
       is not included in
         functor {\color{green}{}(B : ...(B))} {\color{red}{}\bfseries{}(Y : ...(Y))} {\color{green}{}(Z : ...(Z))} -> ...
  {\color{green}{}1.} Module types ...(X) and ...(B) match
  {\color{red}{}\bfseries{}2.} An argument appears to be missing with module type
         ...(Y) = sig type yu = Y of B.u end
  {\color{green}{}3.} Module types ...(Z) and ...(Z) match
\end{alltt}
\end{frame}


\begin{frame}[fragile]\frametitle{Variadic functors}
  \structure{Not all functors have a well-defined arity}
 \begin{minted}{ocaml}
 module F(X:sig
   module type t
   module M:t
 end) = X.M
 module Ft = struct
   module M = F
   module type t = module type of F
 end
\end{minted}
\end{frame}

\begin{frame}[fragile]
\begin{minted}{ocaml}
 module R = F(Ft)(Ft)(Ft)(Ft)(F)
\end{minted}
\begin{alltt}
     These arguments:
       {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{magenta}{}\bfseries{}F}
     do not match these parameters:
       functor {\color{green}{}(X : ...)} {\color{green}{}(X : ...)} {\color{green}{}(X : ...)} {\color{green}{}(X : ...)} {\color{magenta}{}\bfseries{}(X : ...(X))} -> ...
{\color{green}{}1.} Module Ft matches the expected module type
{\color{green}{}2.} Module Ft matches the expected module type
{\color{green}{}3.} Module Ft matches the expected module type
{\color{green}{}4.} Module Ft matches the expected module type
{\color{magenta}{}\bfseries{}5.} Modules do not match:
     F : functor (X : sig module type t module M : t end) -> X.t
   is not included in
     ...(X) = sig module type t module M : t end
   Modules do not match:
     functor {\color{red}{}\bfseries{}(X : ...(X))} -> ...
   is not included in
     functor {\color{red}{}\bfseries{}} -> ...
      An extra argument is provided of module type
          ...(X) = sig module type t module M : t end

\end{alltt}
\end{frame}

\begin{frame}[fragile] \frametitle{A question of performances?}
  \begin{itemize}
    \item{Quadractic module comparisons}
    \item{Errors are for human. Human are slow.}
    \item{Which effect matters?}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{A not that small functor}
  \begin{itemize}
    \item A 26 argument functor, with all stdlib modules involved
  \end{itemize}
\begin{alltt}
These arguments:
  {\color{green}{}A} {\color{red}{}\bfseries{}A} {\color{green}{}B} {\color{magenta}{}\bfseries{}C'} {\color{red}{}\bfseries{}} {\color{green}{}E} {\color{magenta}{}\bfseries{}F'} {\color{green}{}G} {\color{green}{}H} {\color{red}{}\bfseries{}H'} {\color{green}{}I} {\color{green}{}J} {\color{red}{}\bfseries{}} {\color{green}{}L} {\color{green}{}M} {\color{magenta}{}\bfseries{}N'} {\color{green}{}O} {\color{red}{}\bfseries{}O'} {\color{green}{}P} {\color{red}{}\bfseries{}} {\color{green}{}R} {\color{green}{}S} {\color{magenta}{}\bfseries{}T'} {\color{magenta}{}\bfseries{}U'} {\color{green}{}V} {\color{green}{}W} {\color{red}{}\bfseries{}W} {\color{green}{}X} {\color{green}{}Y} {\color{green}{}Z} {\color{red}{}\bfseries{}Z}
do not match these parameters:
  functor {\color{green}{}(A : ...)} {\color{red}{}\bfseries{}} {\color{green}{}(B : ...)} {\color{magenta}{}\bfseries{}(C : ...(C))} {\color{red}{}\bfseries{}(D : ...(D))} {\color{green}{}(E : ...)}
  {\color{magenta}{}\bfseries{}(F : ...(F))} {\color{green}{}(G : ...)} {\color{green}{}(H : ...)} {\color{red}{}\bfseries{}} {\color{green}{}(I : ...)} {\color{green}{}(J : ...)} {\color{red}{}\bfseries{}(K : ...(K))}
  {\color{green}{}(L : ...)} {\color{green}{}(M : ...)} {\color{magenta}{}\bfseries{}(N : ...(N))} {\color{green}{}(O : ...)} {\color{red}{}\bfseries{}} {\color{green}{}(P : ...)} {\color{red}{}\bfseries{}(Q : ...(Q))}
  {\color{green}{}(R : ...)} {\color{green}{}(S : ...)} {\color{magenta}{}\bfseries{}(T : ...(T))} {\color{magenta}{}\bfseries{}(U : ...(U))} {\color{green}{}(V : ...)} {\color{green}{}(W : ...)} {\color{red}{}\bfseries{}}
  {\color{green}{}(X : ...)} {\color{green}{}(Y : ...)} {\color{green}{}(Z : ...)} {\color{red}{}\bfseries{}} -> ...
\end{alltt}

  \begin{itemize}
    \item 100 ms with ocamlopt
  \end{itemize}

\end{frame}


  \begin{frame}[fragile]
  \begin{minted}{ocaml}
module M = F
    (Ft)(Ft)(List)(Ft)(Ft)(Ft)(List)(Ft)(Ft)(List)
    (Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)
    (Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)
    (Ft)(Ft)(Ft)(Ft)(Ft)(Arg)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)
    (Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)
    (Ft)(Ft)(Ft)(Float)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)
    (Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)
    (Ft)(Ft)(Ft)(Ft)(Ft)(Gc)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)
    (Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)
    (Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Map)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)
    (Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)
    (Ft)(Ft)(Seq)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)
    (Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)
    (Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Queue)(Ft)(Ft)(Ft)(Ft)(Ft)
    (Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)
    (Ft)(Ft)(Ft)(Bigarray)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)
    (Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)
    (Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)(Ft)
\end{minted}
\end{frame}

\begin{frame}[fragile]\frametitle{300 ms later}
\begin{alltt}
These arguments:
  {\color{green}{}Ft} {\color{green}{}Ft} {\color{red}{}\bfseries{}List} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{red}{}\bfseries{}List} {\color{green}{}Ft} {\color{green}{}Ft} {\color{red}{}\bfseries{}List} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft}
  {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft}
  {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{red}{}\bfseries{}Arg} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft}
  {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft}
  {\color{red}{}\bfseries{}Float} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft}
  {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{red}{}\bfseries{}Gc} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft}
  {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft}
  {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{red}{}\bfseries{}Map} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft}
  {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{red}{}\bfseries{}Seq} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft}
  {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft}
  {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{red}{}\bfseries{}Queue} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft}
  {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft}
  {\color{red}{}\bfseries{}Bigarray} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft}
  {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft}
  {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft} {\color{green}{}Ft}
do not match these parameters: ...
\end{alltt}

\end{frame}
\begin{frame}
  Visibly not.
  \begin{itemize}
    \item non-optimized implementation of the edit-distance
    \item variadic functors are a worse case
  \end{itemize}
\end{frame}


\section{Future works}

\begin{frame}\frametitle{Future works}
  \begin{itemize}
    \item Signature difference
      \begin{itemize}
        \item ground work is already implemented
        \item The user interface needs to be written.
      \end{itemize}
    \item Moving to types:
      \begin{itemize}
        \item objects are quite similar
      \end{itemize}
    \item Tying everything together
  \end{itemize}

\end{frame}


\end{document}
