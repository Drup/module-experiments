\documentclass{article}
\usepackage{minted}
\usepackage{alltt}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[dvipsnames]{xcolor}

\newcommand{\error}[1]{\textcolor{red}{#1}}
\newcommand{\ok}[1]{\textcolor{OliveGreen}{#1}}

\title{High-level error messages for modules through diffing}
\author{Gabriel Radanne and Florian Angeletti}
\begin{document}
\maketitle

\begin{abstract}
Modules are one of the most complex features of ML languages. This complexity is reflected in error messages.
Whenever two module types are mismatched, it is hard to identify and report the source of the error.
Consequently, type checker often resort to printing the whole module types, and hope that the human user
will be able to navigate the sea of definitions.
We propose to improve module level error messages by coupling classical typechecker and diffing
algorithm. This gives the best of both world, the typechecker deals with the gritty details of
the ML module system whereas the diffing algorithm try to give a higher level view of the error.
And there is a large literature on using diffing algorithm to find the minimal difference between generic trees.
\end{abstract}


Typical uses of module are quite simple. Few people use directly higher-order functor with anonymous module arguments and labyrinth of module type definitions. Quite often, the names of functor arguments and parameters even match:
\begin{minted}{ocaml}
module type XT = sig type x end
module type YT = sig type y end
module F(X: XT)(Y:YT) = struct end
module X = struct type x = A end
module Y = struct type y = B end
module Result = F(X)(Y)
\end{minted}

Another important point is that a lot of module type errors happens during code refactoring, where a handful of changes are common:
\begin{itemize}
\item Adding a new item
\item Removing an old item
\item Changing the type of an item
\end{itemize}

For instance, if we refactor the definition of the functor \texttt{F} above and remove the first argument

\begin{minted}{ocaml}
module F(Y:sig type y end)
\end{minted}

but we forget to update the definition of the \texttt{Result} module, the previously working code

\begin{minted}{ocaml}
module Result = F(X)(Y)
\end{minted}
yields now an error
\begin{alltt}
Error: Signature mismatch:
       Modules do not match: sig type x = X.x = A end is not included in YT
       The type y is required but not provided
\end{alltt}

However, we are not interested in the possibly lengthy mismatch between the module types \texttt{XT} and
\texttt{YT}. We are more interested in the fact that there is an extra functor argument.

This combination of hard to decipher module type errors and a small class of common high-level errors makes
a good argument for trying to give user a higher-level view in functor messages.
Our idea is to use the tree-like shape of module types to compare them using classical diffing algorithm
on trees.

We have an implementation of this approach focusing of functor multi-applications available as a patch to the
Ocaml compiler at
\url{https://github.com/ocaml/ocaml/pull/9331}


\section{Optimising edit-distance for functors}

Functors are a good starting points for a diffing analysis, because there is a
stark contrast between the higher-level view of a functor multi-application

\begin{minted}{ocaml}
module R = F(X_1)...(X_n)
\end{minted}

and the left-to-right biased view of the typechecker.
If type-checking this functor application reports an error at position $k$, the standard
way to report an error would be simply to report the mismatch between expected type of
the $k$th-argument and the $k$th-parameter. But by doing so, we are losing the context of the
functor multi-application.

We can try to do better by consider the whole list of arguments, and trying to find the smallest patched argument lists that makes the multi-application typechecks. A patched argument is then either:

\begin{enumerate}
\item An accepted argument from the original argument list
\item A deleted argument that we throw away from the original argument list
\item An additional argument pulled from the expected parameter list
\item A mismatched argument from the original argument list
\end{enumerate}

It is then natural to assign a positive weight to those patched arguments to represent how far away they
are from the arguments that the user has written.
If only accepted arguments have a zero weight, then we are guaranteed that there is a patched argument list
with minimal weight.

For instance, in our example

\begin{minted}{ocaml}
module Result = F(X)(Y)
\end{minted}

The possible patched arguments would be

\begin{enumerate}
\item \texttt{[Delete(X); Accept(Y)]}
\item \texttt{[Change(X);Delete(Y)]}
\item \texttt{[Add(YT);Delete(X);Delete(Y)]}
\end{enumerate}

The smallest change is clearly the first one. Consequently, rather than reporting
the mismatch between \texttt{XT} and \texttt{YT}, we can simply report \texttt{X}
as an extra-argument:
\begin{minted}{ocaml}
module Result = F(X)(Y)
\end{minted}
\begin{alltt}
\error{Error}: The functor application is ill-typed.
       These arguments:
         \error{X} \ok{Y}
       do not match these parameters:
         functor  \ok{(Y : YT)} -> ...
  \error{1.} The following extra argument is provided X : sig type x = X.x = A end
  \ok{2.} Module Y matches the expected module type YT
\end{alltt}

In term of user-experience, it is important to report that we consider the
functor multi-application as a whole and how we think the code should be corrected.

In term of implementation, using the usual distance matrix for edit-distance computation, we only need
$O((\max \mathrm{number_of_arguments} \mathrm{number_of_parameters} )^2)$ module comparisons in the worse case
scenario.
This seems fine under the assumption that no users write functors with hundreds of arguments.

A possible obstacle with the edit-distance approach is that the arity of functors is not that well-defined.
Consider for instance the case:
\begin{minted}{ocaml}
module F(X:sig
  module type t
  module M:t
end) = M
module Ft = struct
  module M = F
  module type t = module type of F
end
module R = F(Ft)(...)
\end{minted}
Then the arity of \texttt{F} depends on its argument, and it is possible to apply \texttt{F} to
any number of arguments. However, in practice, this only requires a small change to the diffing
algorithm.

\section{Conclusion}

We propose a methodology to improve the user experience of error message for functors in the ML family by making
the error reporter aware of high-level common errors. This is done by combining the classical
inclusion check algorithm and diffing algorithm. This leads to much better focused error messages
that can detect higher-level errors while remaining aware of the low-level errors.

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
