\documentclass{article}

% Encoding and lang
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

% Graphical packages
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{xspace}

% Math
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{thm-restate}
% \usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{textcomp}
\usepackage{gensymb}
% \usepackage{textgreek}
\usepackage{multicol}
\usepackage{ stmaryrd }

\usepackage{fullpage}

\theoremstyle{definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}

\usepackage{listings}
\usepackage[scaled=0.85]{DejaVuSansMono}

\usepackage{caption}
\usepackage{subcaption}
\usepackage[inline,shortlabels]{enumitem}
\setlist{leftmargin=*,noitemsep}
\usepackage{array}
\usepackage{bm}%Decent bolding for math symbols

\usepackage{natbib}% Good citations and bibliography
\usepackage{mathpartir} % Syntax trees

\usepackage[pdfusetitle,colorlinks=true,citecolor=Rhodamine]{hyperref}
\usepackage[noabbrev,capitalize,nameinlink]{cleveref}
\SetLabelAlign{parright}{\parbox[t]{\labelwidth}{\raggedleft#1}}

\newcommand\TODO[1]{{\textbf{\color{red}{TODO: #1}}}}

\title{A parsimonious module system}
\author{TODO}
\date{}

\input{notations}

\begin{document}

\maketitle

\begin{figure}[!hb]
  \input{theory/grammar}
  \caption{Module language}
  \label{grammar}
\end{figure}

Judgements:\\
\begin{description}[align=right, leftmargin=3.5cm]
\item[$\wtm{\E}{\im}{\iM}$ :]
  The module $\im$ is of type $\iM$ in $\E$.
  See \cref{module:typing}.
\item[$\submod{\E}{\iM}{\iM'}{\iM_r}$ :]
  The module type $\iM$ is a subtype of $\iM'$ in $\E$.
  See \cref{module:subtyping}.
\item[$\Oreduce{\E}{\iM} = \iMO$ :]
  The module type with operations $\iM$ can be reduced to a module
  type without operations $\iMO$.
  See \cref{module:strengthen,module:enrich}.
  \TODO{Change bracket style ...}
\end{description}

Operations:\\
\begin{tabular}{ll}
  $\Sstrengthen{l}{\iP}{\iM}$
  & Strenghten $\iM$ by $\iP$ while ignoring the list of module paths $l$.\\
  $\Senrich{\iC}{\iM}$
  & Enrich the module $\iM$ with the constraints $\iC$.\\
  $\Ssubst{\iX : \iM}{\iM'}$
  & Substitutes $\iX$ by $\iM$ in $\iM'$.
  % $\Oforce{\E}{\iM}$
  % & Forces all the operations in $\iM$ until obtaining a simple module type $\iMO$.
\end{tabular}\\

Environment accesses:\\
\begin{tabular}{ll}
  $\lookup{\E}{\ip}$
  & Lookup the module or module type $\ip$ in the environment (i.e., the signature)
    $\E$.\\
  $\resolve{\E}{\iMO}$
  & Resolve $\iMO$ until it's not a path (i.e., either an arrow or a signature).\\
  $\Onormalize{\E}{\iP}$
  & Normalizes the path $\iP$ in $\E$
\end{tabular}

\begin{figure}[tbp]
  \mprset{sep=1.5em}
  \input{theory/typing}\vspace{-3mm}
  \caption{Module typing rules -- $\wtm{\E}{\im}{\iM}$}
  \label{module:typing}
\end{figure}

\begin{figure}[tbp]
  \input{theory/subtyping}\vspace{-3mm}
  \caption{Module subtyping rules -- $\submod{\E}{\iM}{\iM'}{\iM_r}$}
  \label{module:subtyping}
\end{figure}

\begin{figure}[tbp]
  \input{theory/strengthen}
  \caption{Module strengthening operation -- $\Sstrengthen{l}{\iP}{\iM}$}
  \label{module:strengthen}
\end{figure}

\begin{figure}[tbp]
  \input{theory/enrich}
  \caption{Enrichment operation -- $\Senrich{\iC}{\iM}$}
  \label{module:enrich}
\end{figure}

\begin{figure}[tbp]
  \input{theory/lookup}\vspace{-3mm}
  \caption{Lookup rules -- $\lookup{\E}{\ip} = \iM$}
  \label{module:lookup}
% \end{figure}

% \begin{figure}[hbt]
  \begin{subfigure}[t]{0.5\linewidth}
    \begin{align*}
      \Oshape{\E}{\iM} &= \Oshape{\E}{\Oreduce{\E}{\iM}}\\
      \Oshape{\E}{\Salias{\iP}} &= \Oshape{\E}{\resolve{\E}{\iP}}\\
      \Oshape{\E}{\Ssig{\ix}{\iS}} &= \Ssig{\ix}{\iS}\\
      \Oshape{\E}{\Sfunctor{\ix}{\iM}{\iM'}} &= \Sfunctor{\ix}{\iM}{\iM'}
    \end{align*}
  \end{subfigure}
  \begin{subfigure}[t]{0.5\linewidth}
    \begin{align*}
      \resolve{\E}{\iP}
      &= \Sstrengthen{}{\Onormalize{\E}{\iP}}{\lookup{\E}{\Onormalize{\E}{\iP}}}
      \\[1em]
      \Onormalize{\E}{\iP}
      &=
        \begin{dcases}
          \Onormalize{\E}{\iP'} & \text{when } \lookup{\E}{\iP} = \Salias{\iP'} \\
          \iP & \text{otherwise}
        \end{dcases}
    \end{align*}
  \end{subfigure}
% \end{figure}

% % \begin{figure}[p]
%   \input{theory/validity}\vspace{-3mm}
%   \caption{Module type validity rules -- $\wfm{\Env}{\Mm}$}
%   \label{module:validity}
\end{figure}




% \begin{theorem}[Separate Typechecking]\label{ml:separation}
%   Given a list of module declarations that form a typed program, there exists
%   an order such that each module can be typechecked with only knowledge
%   of the type of the previous modules.

%   More formally,
%   given a list of $n$ declarations $\id_i$ and a signature $\iS$ such that
%   \[
%     \wtm{}{(\id_1;\dots;\id_n)}{\iS}
%   \]
%   then there exists $n$ definitions $\iD_i$ and a permutation $\pi$ such that
%   \begin{align*}
%     \forall i < n,\ &
%     \wtm{\iD_{1};\dots;\iD_{i}}{\id_{i+1}}{\iD_{i+1}}&
%     \submod{}{\iD_{\pi(1)};\dots;\iD_{\pi(n)}}{\iS}
%   \end{align*}
% \end{theorem}


\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
